
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Thread pools</title>
    
    <meta name="author" content="Lucas AllanJerry DAntonio">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">Concurrent-ruby</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/about/index.html">About</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/documentation/index.html">Documentation</a></li>
      	
      
    
  
    
      
    
  
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="page-header">
  <h1>Thread pools </h1>
</div>

<div class="row-fluid">
  <div class="span12">
    <h1 id="were_going_to_need_a_bigger_boat">We’re Going to Need a Bigger Boat</h1>

<p>Thread pools are neither a new idea nor an implementation of the actor pattern. Nevertheless, thread pools are still an extremely relevant concurrency tool. Every time a thread is created then subsequently destroyed there is overhead. Creating a pool of reusable worker threads then repeatedly’ dipping into the pool can have huge performace benefits for a long-running application like a service. Ruby’s blocks provide an excellent mechanism for passing a generic work request to a thread, making Ruby an excellent candidate language for thread pools.</p>

<p>The inspiration for thread pools in this library is Java’s <code>java.util.concurrent</code> implementation of <a href="java.util.concurrent">thread pools</a>. The <code>java.util.concurrent</code> library is a well-designed, stable, scalable, and battle-tested concurrency library. It provides three different implementations of thread pools. One of those implementations is simply a special case of the first and doesn’t offer much advantage in Ruby, so only the first two (<code>FixedThreadPool</code> and <code>CachedThreadPool</code>) are implemented here.</p>

<p>Thread pools share common <code>behavior</code> defined by <code>:thread_pool</code>. The most imortant method is <code>post</code> (aliased with the left-shift operator <code>&lt;&lt;</code>). The <code>post</code> method sends a block to the pool for future processing.</p>

<p>A running thread pool can be shutdown in an orderly or disruptive manner. Once a thread pool has been shutdown in cannot be started again. The <code>shutdown</code> method can be used to initiate an orderly shutdown of the thread pool. All new <code>post</code> calls will reject the given block and immediately return <code>false</code>. Threads in the pool will continue to process all in-progress work and will process all tasks still in the queue. The <code>kill</code> method can be used to immediately shutdown the pool. All new <code>post</code> calls will reject the given block and immediately return <code>false</code>. Ruby’s <code>Thread.kill</code> will be called on all threads in the pool, aborting all in-progress work. Tasks in the queue will be discarded.</p>

<p>A client thread can choose to block and wait for pool shutdown to complete. This is useful when shutting down an application and ensuring the app doesn’t exit before pool processing is complete. The method <code>wait_for_termination</code> will block for a maximum of the given number of seconds then return <code>true</code> if shutdown completed successfully or <code>false</code>. When the timeout value is <code>nil</code> the call will block indefinitely. Calling <code>wait_for_termination</code> on a stopped thread pool will immediately return <code>true</code>.</p>

<p>Predicate methods are provided to describe the current state of the thread pool. Provided methods are <code>running?</code>, <code>shutdown?</code>, and <code>killed?</code>. The <code>shutdown</code> method will return true regardless of whether the pool was shutdown wil <code>shutdown</code> or <code>kill</code>.</p>

<h2 id="fixedthreadpool">FixedThreadPool</h2>

<p>From the docs:</p>

<blockquote>
<p>Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most <code>nThreads</code> threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly <code>shutdown</code>.</p>
</blockquote>

<h3 id="examples">Examples</h3>

<pre class="ruby"><code class="ruby">
require 'concurrent'

pool = Concurrent::FixedThreadPool.new(5)

pool.size     #=&gt; 5
pool.running? #=&gt; true
pool.status   #=&gt; [&quot;sleep&quot;, &quot;sleep&quot;, &quot;sleep&quot;, &quot;sleep&quot;, &quot;sleep&quot;]

pool.post(1,2,3){|*args| sleep(10) }
pool &lt;&lt; proc{ sleep(10) }
pool.size     #=&gt; 5

sleep(11)
pool.status   #=&gt; [&quot;sleep&quot;, &quot;sleep&quot;, &quot;sleep&quot;, &quot;sleep&quot;, &quot;sleep&quot;]

pool.shutdown #=&gt; :shuttingdown
pool.status   #=&gt; []
pool.wait_for_termination

pool.size      #=&gt; 0
pool.status    #=&gt; []
pool.shutdown? #=&gt; true
</code></pre>

<h2 id="cachedthreadpool">CachedThreadPool</h2>

<p>From the docs:</p>

<blockquote>
<p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to [] will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using [] constructors.</p>
</blockquote>

<h3 id="examples_2">Examples</h3>

<pre class="ruby"><code class="ruby">
require 'concurrent'

pool = Concurrent::CachedThreadPool.new

pool.size     #=&gt; 0
pool.running? #=&gt; true
pool.status   #=&gt; []

pool.post(1,2,3){|*args| sleep(10) }
pool &lt;&lt; proc{ sleep(10) }
pool.size     #=&gt; 2
pool.status   #=&gt; [[:working, nil, &quot;sleep&quot;], [:working, nil, &quot;sleep&quot;]]

sleep(11)
pool.status   #=&gt; [[:idle, 23, &quot;sleep&quot;], [:idle, 23, &quot;sleep&quot;]]

sleep(60)
pool.size     #=&gt; 0
pool.status   #=&gt; []

pool.shutdown #=&gt; :shuttingdown
pool.status   #=&gt; []
pool.wait_for_termination

pool.size      #=&gt; 0
pool.status    #=&gt; []
pool.shutdown? #=&gt; true
</code></pre>

<h2 id="global_thread_pool">Global Thread Pool</h2>

<p>For efficiency, of the aforementioned concurrency methods (agents, futures, promises, and goroutines) run against a global thread pool. This pool can be directly accessed through the <code>$GLOBAL_THREAD_POOL</code> global variable. Generally, this pool should not be directly accessed. Use the other concurrency features instead.</p>

<p>By default the global thread pool is a <code>NullThreadPool</code>. This isn’t a real thread pool at all. It’s simply a proxy for creating new threads on every post to the pool. I couldn’t decide which of the other threads pools and what configuration would be the most universally appropriate so I punted. If you understand thread pools then you know enough to make your own choice. That’s why the global thread pool can be changed.</p>

<h3 id="changing_the_global_thread_pool">Changing the Global Thread Pool</h3>

<p>It is possible to change the global thread pool. Simply assign a new pool to the <code>$GLOBAL_THREAD_POOL</code> variable:</p>

<pre class="ruby"><code class="ruby">
$GLOBAL_THREAD_POOL = Concurrent::FixedThreadPool.new(10)
</code></pre>

<p>Ideally this should be done at application startup, before any concurrency functions are called. If the circumstances warrant the global thread pool can be changed at runtime. Just make sure to shutdown the old global thread pool so that no tasks are lost:</p>

<pre class="ruby"><code class="ruby">
$GLOBAL_THREAD_POOL = Concurrent::FixedThreadPool.new(10)

# do stuff...

old_global_pool = $GLOBAL_THREAD_POOL
$GLOBAL_THREAD_POOL = Concurrent::FixedThreadPool.new(10)
old_global_pool.shutdown
</code></pre>

<h3 id="nullthreadpool">NullThreadPool</h3>

<p>If for some reason an appliction would be better served by <em>not</em> having a global thread pool, the <code>NullThreadPool</code> is provided. The <code>NullThreadPool</code> is compatible with the global thread pool but it is not an actual thread pool. Instead it spawns a new thread on every call to the <code>post</code> method.</p>

<h3 id="eventmachine">EventMachine</h3>

<p>The <a href="http://rubyeventmachine.com/">EventMachine</a> library (source <a href="https://github.com/eventmachine/eventmachine">online</a>) is an awesome library for creating evented applications. EventMachine provides its own thread pool and the authors recommend using their pool rather than using Ruby’s <code>Thread</code>. No sweat, <code>concurrent-ruby</code> is fully compatible with EventMachine. Simple require <code>eventmachine</code> <em>before</em> requiring <code>concurrent-ruby</code> then replace the global thread pool with an instance of <code>EventMachineDeferProxy</code>:</p>

<pre class="ruby"><code class="ruby">
require 'eventmachine' # do this FIRST
require 'concurrent'

$GLOBAL_THREAD_POOL = EventMachineDeferProxy.new
</code></pre>

<h2 id="perclass_thread_pools">Per-class Thread Pools</h2>

<p>Many of the classes in this library use the global thread pool rather than creating new threads. Classes such as <code>Agent</code>, <code>Defer</code>, and others follow this pattern. There may be cases where a program would be better suited for one or more of these classes used a different thread pool. All classes that use the global thread pool support a class-level <code>thread_pool</code> attribute accessor. This property defaults to the global thread pool but can be changed at any time. Once changed, all new instances of that class will use the new thread pool.</p>

<pre class="ruby"><code class="ruby">
Concurrent::Agent.thread_pool == $GLOBAL_THREAD_POOL #=&gt; true

$GLOBAL_THREAD_POOL = Concurrent::FixedThreadPool.new(10) #=&gt; #&lt;Concurrent::FixedThreadPool:0x007fe31130f1f0 ...

Concurrent::Agent.thread_pool == $GLOBAL_THREAD_POOL #=&gt; false

Concurrent::Defer.thread_pool = Concurrent::CachedThreadPool.new #=&gt; #&lt;Concurrent::CachedThreadPool:0x007fef1c6b6b48 ...
Concurrent::Defer.thread_pool == Concurrent::Agent.thread_pool #=&gt; false
Concurrent::Defer.thread_pool == $GLOBAL_THREAD_POOL #=&gt; false
</code></pre>

<h2 id="copyright">Copyright</h2>

<p><em>Concurrent Ruby</em> is Copyright © 2013 <a href="https://twitter.com/jerrydantonio">Jerry D’Antonio</a>. It is free software and may be redistributed under the terms specified in the LICENSE file.</p>

<h2 id="license">License</h2>

<p>Released under the MIT license.</p>

<p>http://www.opensource.org/licenses/mit-license.php</p>

<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br />of this software and associated documentation files (the “Software”), to deal<br />in the Software without restriction, including without limitation the rights<br />to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br />copies of the Software, and to permit persons to whom the Software is<br />furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in<br />all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br />IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br />FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br />AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br />LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br />OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br />THE SOFTWARE.</p>
</blockquote>
  </div>
</div>


      </div>
      <hr>
      <footer>
      </footer>

    </div>

    
  </body>
</html>

